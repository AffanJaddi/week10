name: SIT722 CD - Production (main)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  ACR_NAME: ${{ secrets.ACR_NAME }}
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  PROD_NAMESPACE: prod
  AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}
  AKS_CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}

jobs:
  test_build_push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ==== DIAGNOSTICS: show what actually exists ====
      - name: Show repo layout
        run: |
          echo "PWD: $(pwd)"
          ls -la
          echo "---- level 1 ----"
          find . -maxdepth 1 -type d -print
          echo "---- level 2 ----"
          find . -maxdepth 2 -type d -print
          echo "---- level 3 ----"
          find . -maxdepth 3 -type d -print

      # ---- Backend sanity tests (run only if path exists) ----
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"

      - name: Product tests
        if: ${{ hashFiles('backend/product-service/pom.xml') != '' }}
        working-directory: backend/product-service
        run: ./mvnw -B -DskipTests=false test

      - name: Order tests
        if: ${{ hashFiles('backend/order-service/pom.xml') != '' }}
        working-directory: backend/order-service
        run: ./mvnw -B -DskipTests=false test

      - name: Customer tests
        if: ${{ hashFiles('backend/customer-service/pom.xml') != '' }}
        working-directory: backend/customer-service
        run: ./mvnw -B -DskipTests=false test

      # ---- Azure/ACR auth ----
      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ACR login
        run: az acr login --name $ACR_NAME

      # ---- Build & push images (only if Dockerfile exists) ----
      - name: Build & Push product (prod)
        if: ${{ hashFiles('backend/product-service/Dockerfile') != '' }}
        uses: docker/build-push-action@v6
        with:
          context: ./backend/product-service
          push: true
          tags: |
            ${{ env.ACR_LOGIN_SERVER }}/product:${{ github.sha }}
            ${{ env.ACR_LOGIN_SERVER }}/product:prod-${{ github.sha }}

      - name: Build & Push order (prod)
        if: ${{ hashFiles('backend/order-service/Dockerfile') != '' }}
        uses: docker/build-push-action@v6
        with:
          context: ./backend/order-service
          push: true
          tags: |
            ${{ env.ACR_LOGIN_SERVER }}/order:${{ github.sha }}
            ${{ env.ACR_LOGIN_SERVER }}/order:prod-${{ github.sha }}

      - name: Build & Push customer (prod)
        if: ${{ hashFiles('backend/customer-service/Dockerfile') != '' }}
        uses: docker/build-push-action@v6
        with:
          context: ./backend/customer-service
          push: true
          tags: |
            ${{ env.ACR_LOGIN_SERVER }}/customer:${{ github.sha }}
            ${{ env.ACR_LOGIN_SERVER }}/customer:prod-${{ github.sha }}

      # Frontend is static nginx â€” build only if Dockerfile exists
      - name: Build & Push frontend (prod, static)
        if: ${{ hashFiles('frontend/Dockerfile') != '' }}
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          push: true
          tags: |
            ${{ env.ACR_LOGIN_SERVER }}/frontend:${{ github.sha }}
            ${{ env.ACR_LOGIN_SERVER }}/frontend:prod-${{ github.sha }}

  deploy_prod:
    needs: test_build_push
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Ensure prod namespace exists
        run: kubectl create namespace ${{ env.PROD_NAMESPACE }} || true

      # If your render script doesn't exist, this will fail.
      # We guard it and show a helpful message instead.
      - name: Check render script exists
        id: has_script
        run: |
          if [ -f ".github/scripts/render_manifests.sh" ]; then
            echo "present=true" >> $GITHUB_OUTPUT
          else
            echo "present=false" >> $GITHUB_OUTPUT
          fi

      - name: Render manifests (inject image tags & namespace)
        if: steps.has_script.outputs.present == 'true'
        env:
          NAMESPACE: ${{ env.PROD_NAMESPACE }}
          ACR_LOGIN_SERVER: ${{ env.ACR_LOGIN_SERVER }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          bash .github/scripts/render_manifests.sh k8s/base rendered
          echo "Rendered files:" && ls -la rendered

      # Fallback: simple sed render if the script is missing
      - name: Render manifests (fallback)
        if: steps.has_script.outputs.present != 'true'
        env:
          NAMESPACE: ${{ env.PROD_NAMESPACE }}
          ACR_LOGIN_SERVER: ${{ env.ACR_LOGIN_SERVER }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          mkdir -p rendered
          for f in k8s/base/*deploy.yaml; do
            bn=$(basename "$f")
            sed -e "s|\${NAMESPACE}|$NAMESPACE|g" \
                -e "s|\${ACR_LOGIN_SERVER}|$ACR_LOGIN_SERVER|g" \
                -e "s|\${IMAGE_TAG}|$IMAGE_TAG|g" \
                "$f" > "rendered/$bn"
          done
          echo "Rendered files (fallback):" && ls -la rendered

      - name: Deploy to production
        run: |
          kubectl apply -f rendered/ || { echo "Rendered manifests missing. Check k8s/base paths."; exit 1; }

          # Rollout only for deployments that exist in the repo
          for d in product order customer frontend; do
            if kubectl -n ${{ env.PROD_NAMESPACE }} get deploy "$d" >/dev/null 2>&1; then
              echo "Waiting for deployment/$d..."
              kubectl -n ${{ env.PROD_NAMESPACE }} rollout status deploy/$d --timeout=180s
            else
              echo "deployment/$d not found in namespace ${{ env.PROD_NAMESPACE }} (skipping)"
            fi
          done

      - name: Post-deploy check
        run: kubectl -n ${{ env.PROD_NAMESPACE }} get all,ingress,svc -o wide
